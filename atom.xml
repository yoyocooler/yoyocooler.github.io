<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YOYOCOOL-Blog</title>
  
  <subtitle>希望在25岁之前能找到坚定一生的信念</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-04T09:56:17.187Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yoyocool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二章 线性表</title>
    <link href="http://example.com/undefined/3ad7441d.html"/>
    <id>http://example.com/undefined/3ad7441d.html</id>
    <published>2024-07-04T09:45:51.299Z</published>
    <updated>2024-07-04T09:56:17.187Z</updated>
    
    <content type="html"><![CDATA[<hr><p>🚗文档目录：🚀<a href="http://localhost:4000/undefined/dcf64845.html">绪论</a>&nbsp; &nbsp;🚲<a href="http://localhost:4000/undefined/3ad7441d.html">线性表</a></p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>n个类型相同的数据元素的有限序列。对n&gt;0，除第一元素无直接前驱，第二元素无直接后继外，其余每个数据元素只有一个直接前驱和一个直接后继。</p><p><strong>线性表的特点：</strong></p><ol><li><p>同一性</p></li><li><p>有穷性</p></li><li><p>有序性</p></li></ol><h1 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType elem[MAXSIZE];<span class="comment">//线性表占用的数组空间</span></span><br><span class="line">    <span class="type">int</span> last;<span class="comment">//最后一个元素的下标值</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><p><strong>设SeqList L</strong></p><ol><li><p>L.elem[i-1]：第i个元素</p></li><li><p>L.last：最后一个元素的下标值</p></li><li><p>L.last+1：顺序表的长度</p></li></ol><p><strong>设SeqList *L</strong></p><ol><li><p>L-&gt;elem[i-1]：第i个元素</p></li><li><p>L-&gt;last+1：顺序表的长度</p></li></ol><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>按序号查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetData</span><span class="params">(SeqList L,<span class="type">int</span> i)</span>&#123;<span class="comment">//查找序号为i的元素，并返回该元素值</span></span><br><span class="line">    <span class="keyword">return</span> L.elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按内容查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SeqList L,ElemType e)</span>&#123;<span class="comment">//查找值为e的元素，返回序号，若找不到返回-1</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=L.last)&amp;&amp;(L.elem[i]!=e))</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L.last)</span><br><span class="line">        <span class="keyword">return</span>(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//时间复杂度为O（n）</span></span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsList</span><span class="params">(SeqList *L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">//先判断插入位置是否合法。</span></span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L-&gt;last+<span class="number">2</span>))<span class="comment">//i=last+2表示插在最后</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i值不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再判断表是否已满</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;last&gt;=MAXSIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表已满，无法插入&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为插入元素而移动位置</span></span><br><span class="line">    <span class="keyword">for</span>(k=L-&gt;last;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">        L-&gt;elem[k+<span class="number">1</span>]=L-&gt;elem[k];</span><br><span class="line">    L-&gt;elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    L-&gt;last++;<span class="comment">//最后元素后移，下标值+1</span></span><br><span class="line">    <span class="keyword">return</span>(OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DelList</span><span class="params">(SeqList *L,<span class="type">int</span> i,ElemType *e)</span>&#123;<span class="comment">//删除L表中第i个元素，用指针参数e返回其值</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">//先判断删除位置合不合法</span></span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L-&gt;last+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    *e=L-&gt;elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//移动元素位置</span></span><br><span class="line">    <span class="keyword">for</span>(k=i;i&lt;=L-&gt;last;k++)</span><br><span class="line">        L-&gt;elem[k<span class="number">-1</span>]=L-&gt;elem[k];</span><br><span class="line">    L-&gt;last--;</span><br><span class="line">    <span class="keyword">return</span>(OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两表合并"><a href="#两表合并" class="headerlink" title="两表合并"></a>两表合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergeList</span><span class="params">(SeqList LA,SeqList LB,SeqList *LC)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=LA.last&amp;&amp;j&lt;=LB.last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(LA.elem[i]&lt;=LB.elem[j])&#123;</span><br><span class="line">            LC-&gt;elem[k]=LA.elem[i];</span><br><span class="line">            i++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LC-&gt;elem[k]=LB.elem[j];</span><br><span class="line">            j++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=LA.last)&#123;<span class="comment">//将LA的剩余元素赋给LC</span></span><br><span class="line">        LC-&gt;elem[k]=LA.elem[i];</span><br><span class="line">        i++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=LB.last)&#123;<span class="comment">//将LB的剩余元素赋给LC</span></span><br><span class="line">        LC-&gt;elem[k]=LB.elem[j];</span><br><span class="line">        j++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    LC-&gt;last=LA.last+LB.last+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h1><p>用一组任意的存储单元来存放线性表的结点。</p><p>链表的结点包含：<strong>数据域：</strong> 存储结点的值；<strong>指针域：</strong> 存储数据元素的直接后继的地址（或位置）</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>只有一个next的链表</p><p>设<strong>头指针H</strong>指向第一节点</p><p>在单链表第一个结点之前设一个<strong>头结点</strong>，头结点的数据域存储线性表长度等附加信息，或不存储信息，头结点的指针域指向第一个结点，此时头指针H指向头结点。若线性表为空表，则头结点的指针域为“空”。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    *L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//开辟一个存放Node类型头结点的头指针</span></span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;<span class="comment">//建立空的单链表L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p><strong>头插法：</strong></p><p>从空表开始，每次读入数据，生成新结点，将读入数据存放到新结点的数据域中，将新结点插入头结点之后，直到读入结束。</p><p>生成节点顺序与输入顺序相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateFromHead</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    Node *s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        c=getchar();</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;$&#x27;</span>)&#123;<span class="comment">//输入‘$’建表结束</span></span><br><span class="line">            s=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            s-&gt;data=c;</span><br><span class="line">            s-&gt;next=L-&gt;next;</span><br><span class="line">            L-&gt;next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾插法：</strong></p><p>将新结点插入到表尾上，增加一个r指针指向表尾。</p><p>生成节点顺序与输入顺序相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateFromTail</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    Node *s,*r;</span><br><span class="line">    r=L;<span class="comment">//r指向头结点</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        c=getchar();</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;$&#x27;</span>)&#123;<span class="comment">//输入‘$’建表结束</span></span><br><span class="line">            s=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            s-&gt;data=c;</span><br><span class="line">            r-&gt;next=s;</span><br><span class="line">            r=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点指针指向空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p><strong>按序号查找：</strong></p><p>从头指针L出发，从头结点开始扫描，用指针p指向当前扫描到的结点，用j做计数器，累计当前扫描过的结点数，当j==i时，指针p指向的结点即所找结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">GetData</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//考虑i不合法的情况</span></span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next!=<span class="literal">NULL</span>)&amp;&amp;(j&lt;i))&#123;<span class="comment">//考虑进找不到的情况</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按值查找：</strong></p><p>从头结点出发，逐个将结点值与给定值e比较，返回查找结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">Locate</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=L-&gt;next;<span class="comment">//从头结点开始找</span></span><br><span class="line">    <span class="keyword">while</span>(p!=NUll)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data!=e)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h3><p>从头结点开始数，用指针p指向各个结点，设j作为计数器，直到数完最后一个结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    p=L-&gt;next;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O（n）</span></span><br></pre></td></tr></table></figure><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><ol><li><p>查找：找到第i-1个结点并由指针pre指示。</p></li><li><p>申请：申请新结点s，将其数据域的值置为e。</p></li><li><p>插入：通过修改指针域将新结点s挂入表L中。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsList</span><span class="params">(LinkList L,<span class="type">int</span> i,<span class="type">char</span> e)</span>&#123;</span><br><span class="line">    Node *pre,*s;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    pre=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((pre-&gt;next!=<span class="literal">NULL</span>)&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;<span class="comment">//找到第i-1个元素，或找到最后一个元素</span></span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i<span class="number">-1</span>)&#123;</span><br><span class="line">        s=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;next=pre-&gt;next;</span><br><span class="line">        pre-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ol><li><p>查找：找到第i-1个结点并由指针pre指示。</p></li><li><p>删除：让指针r指向第i个结点，删除第i个结点并释放空间。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DelList</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">    Node *pre,*r;<span class="comment">//*r指向被删除元素</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    pre=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((pre-&gt;next!=<span class="literal">NULL</span>)&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> ERROR</span><br><span class="line">    r=pre-&gt;next;</span><br><span class="line">    *e=r-&gt;data;<span class="comment">//*e保存被删除元素的值</span></span><br><span class="line">    pre-&gt;next=r-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(r);<span class="comment">//释放被删除元素的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两表合并-1"><a href="#两表合并-1" class="headerlink" title="两表合并"></a>两表合并</h3><p>利用现有表LA和LB，建立新表LC，通过更改结点的next域来重建新的关系，采用尾插法保证仍然递增有序，选择LA和LB中合适的点插入LC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">MergeLinkList</span><span class="params">(LinkList LA,LinkList LB)</span>&#123;</span><br><span class="line">    Node *pa,*pb,*r;<span class="comment">//r为指向LC尾结点的尾指针</span></span><br><span class="line">    LinkList LC;</span><br><span class="line">    pa=LA-&gt;next;pb=LB-&gt;next;</span><br><span class="line">    LC=LA;<span class="comment">//将LA的头结点空间给LC</span></span><br><span class="line">    LC-&gt;next=<span class="literal">NULL</span>;<span class="comment">//这一条必须在pa=LA-&gt;next;后执行</span></span><br><span class="line">    r=LC;</span><br><span class="line">    <span class="keyword">while</span>((pa!=<span class="literal">NULL</span>)&amp;&amp;(pb!=<span class="literal">NULL</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;</span><br><span class="line">            r-&gt;next=pa;</span><br><span class="line">            r=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next=pb;</span><br><span class="line">            r=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa)&#123;</span><br><span class="line">        r-&gt;next=pa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r-&gt;next=pb;</span><br><span class="line">    <span class="built_in">free</span>(LB);<span class="comment">//释放的是LB指向的头结点，此时链表B已经为C的一部分</span></span><br><span class="line">    <span class="keyword">return</span> LC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>首尾相接的链表，单链表尾结点的next指向头结点。</p><p>头指针L指向头结点/尾指针rear指向尾结点</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCLinkList</span><span class="params">(LinkList *CL)</span>&#123;</span><br><span class="line">    *CL=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*CL)-&gt;next=*CL;<span class="comment">//头结点的next指向它本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立-1"><a href="#建立-1" class="headerlink" title="建立"></a>建立</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateCLinkList</span><span class="params">(LinkList CL)</span>&#123;</span><br><span class="line">    Node *rear,*s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    rear=CL;</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="string">&#x27;$&#x27;</span>)&#123;</span><br><span class="line">        s=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data=c;</span><br><span class="line">        rear-&gt;next=s;</span><br><span class="line">        rear=s;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next=CL;<span class="comment">//让最后一个节点的next指向头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两表"><a href="#合并两表" class="headerlink" title="合并两表"></a>合并两表</h2><p><strong>使用头指针的两表：</strong></p><p>找到LA,LB的表尾，分别用p、q指向他们，将A的尾结点与B的第一个结点链接，并使q的next指向A的头结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">merge_2</span><span class="params">(LinkList RA,LinkList RB)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=RA-&gt;next;</span><br><span class="line">    RA-&gt;next=RB-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(RB-&gt;next);<span class="comment">//释放RB的头结点。</span></span><br><span class="line">    RB-&gt;next=p;</span><br><span class="line">    <span class="keyword">return</span>(RA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用尾指针的两表：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">merge_2</span><span class="params">(LinkList RA,LinkList RB)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=RA-&gt;next;</span><br><span class="line">    RA-&gt;next=RB-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(RB-&gt;next);<span class="comment">//释放RB的头结点。</span></span><br><span class="line">    RB-&gt;next=p;</span><br><span class="line">    <span class="keyword">return</span>(RA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表的每个结点中再增加一个指向其前驱的指针域prior</p><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,* DoubleList;</span><br></pre></td></tr></table></figure><h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DlinkIns</span><span class="params">(DoubleList L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    DNode *p,*s;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(s)&#123;</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;next=p;</span><br><span class="line">        s-&gt;prior=p-&gt;prior;</span><br><span class="line">        p-&gt;prior=s;</span><br><span class="line">        s-&gt;prior-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DlinkDel</span><span class="params">(DoubleList L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    DNode *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=L&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;i)<span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=p-&gt;data;<span class="comment">//注意不要忘了星号*</span></span><br><span class="line">    p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性表应用——一元多项式的表示及相加"><a href="#线性表应用——一元多项式的表示及相加" class="headerlink" title="线性表应用——一元多项式的表示及相加"></a>线性表应用——一元多项式的表示及相加</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h3><ol><li><p>只存储一元多项式的系数，系数的指数项隐含在系数的下标中。</p></li><li><p>只存储非零系数和非零指数。</p></li></ol><h3 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h3><p>只存非零项，每一项包含指数项和系数项，及指针域next</p><h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;<span class="comment">//系数</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;<span class="comment">//指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Polynode,* Polylist;</span><br></pre></td></tr></table></figure><h4 id="建立-2"><a href="#建立-2" class="headerlink" title="建立"></a>建立</h4><p>输入一组多项式的系数和指数，采用尾插法，以输入系数0为结束标志，并总是按指数从小到大排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Polylist <span class="title function_">PolyCreate</span><span class="params">()</span>&#123;</span><br><span class="line">    Polynode *head,*rear,*s;</span><br><span class="line">    <span class="type">int</span> c,e;</span><br><span class="line">    head=(Polynode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Polynode));<span class="comment">//建立多项式的头指针</span></span><br><span class="line">    rear=head;<span class="comment">//rear指向多项式的尾结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;c,&amp;e);</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">        s=(Polynode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Polynode));</span><br><span class="line">        s-&gt;coef=c;</span><br><span class="line">        s-&gt;<span class="built_in">exp</span>=e;</span><br><span class="line">        rear-&gt;next=s;</span><br><span class="line">        rear=s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;c,&amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾指针的next指向空</span></span><br><span class="line">    <span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相加运算"><a href="#相加运算" class="headerlink" title="相加运算"></a>相加运算</h4><ol><li><p>用单链表polya和polyb表示两个一元多项式A和B，A+B求和等同于单链表的插入（将polyb插入polya中。</p></li><li><p>设p、q分别指向polya和polyb的当前项，比较p、q的指数项</p><ol><li><p>若p-&gt;exp &lt; q-&gt;exp，则将p加入多项式，p后移</p></li><li><p>若p-&gt;exp = q-&gt;exp，则p和q系数相加，若和不为0则修改p的系数域，若和为0则无此项，删去p，并释放p和q</p></li><li><p>若p-&gt;exp &gt; q-&gt;exp，则q插入p之前，并令q在原来的链表中后移</p></li></ol></li><li><p>使用尾插法，tail指针记录当前“和多项式”的尾结点，待插入的结点的直接前驱。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PolyAdd</span><span class="params">(Polylist polya,Polylist polyb)</span>&#123;</span><br><span class="line">Polynode *pa,*pb,*tail,*temp;<span class="comment">//temp作为临时结点，存需要释放的结点</span></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line">pa=polya-&gt;next;pb=polyb-&gt;next;</span><br><span class="line">tail=polya;</span><br><span class="line"><span class="keyword">while</span>(pa!=<span class="literal">NULL</span>&amp;&amp;pb!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;<span class="built_in">exp</span>&lt;pb-&gt;<span class="built_in">exp</span>)&#123;</span><br><span class="line">tail-&gt;next=pa;pa=pa-&gt;next;tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;<span class="built_in">exp</span>==pb-&gt;<span class="built_in">exp</span>)&#123;</span><br><span class="line">sum=pa-&gt;coef+pb-&gt;coef;</span><br><span class="line"><span class="keyword">if</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">tail-&gt;next=pa;temp=pb;</span><br><span class="line">pa=pa-&gt;next;pb=pb-&gt;next;tail=tail-&gt;next;</span><br><span class="line">tail-&gt;coef=sum;<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">temp=pa;pa=pa-&gt;next;<span class="built_in">free</span>(temp);</span><br><span class="line">temp=pb;pb=pb-&gt;next;<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tail-&gt;next=pb;pb=pb-&gt;next;tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pa!=<span class="literal">NULL</span>)tail-&gt;next=pa;</span><br><span class="line"><span class="keyword">else</span> tail-&gt;next=pb;</span><br><span class="line"><span class="built_in">free</span>(polyb);</span><br><span class="line">&#125;<span class="comment">//时间复杂度O（m+n）</span></span><br></pre></td></tr></table></figure><h1 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h1><h2 id="顺序表与链表"><a href="#顺序表与链表" class="headerlink" title="顺序表与链表"></a>顺序表与链表</h2><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>线性表长度变化较大难以估计其存储规模时，采用动态链表。</p><p>线性表长度变化不大，易于事先确定其大小，很少做插入删除操作，采用顺序表。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>主要进行查找，则顺序表</p><p>主要插入或删除，用链表；插入删除主要发生首尾两端，用带尾指针的单循环链表。</p><h2 id="链表存储方式"><a href="#链表存储方式" class="headerlink" title="链表存储方式"></a>链表存储方式</h2><p>见课本P68-P69</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;🚗文档目录：🚀&lt;a href=&quot;http://localhost:4000/undefined/dcf64845.html&quot;&gt;绪论&lt;/a&gt;&amp;nbsp; &amp;nbsp;🚲&lt;a href=&quot;http://localhost:4000/undefined/3ad74</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第一章 绪论</title>
    <link href="http://example.com/undefined/dcf64845.html"/>
    <id>http://example.com/undefined/dcf64845.html</id>
    <published>2024-06-29T06:37:01.105Z</published>
    <updated>2024-07-04T09:56:18.127Z</updated>
    
    <content type="html"><![CDATA[<hr><p>🚗文档目录：</p><p>🚀<a href="http://localhost:4000/undefined/dcf64845.html">绪论</a>&nbsp; &nbsp; 🚲<a href="">线性表</a></p><hr><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><em>描述客观事物的数值、字符以及能输入计算机且能被处理的各种符号集合。</em></p><p><strong>特点：</strong></p><ol><li><p>可被计算机接收</p></li><li><p>可被加工</p></li></ol><p><strong>构成：</strong></p><ol><li><p>数据元素</p></li><li><p>数据对象</p></li></ol><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p><em>组成数据的<strong>基本单位</strong>，是数据集合的个体。</em></p><p>数据项：有独立意义的最小单位</p><p>n个<u>数据项</u>【单元格】→m个<u>数据元素</u>（记录）【行】→<u>数据</u>【表】</p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p><em><u>性质相同</u>的<u>数据元素</u>的集合，是数据的一个子集。</em></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>定义：</strong> 相互之间存在一种或多种特定关系的数据元素集合。（<u>数据元素集合</u>及<u>元素间关系的集合</u>）</p><p><strong>研究：</strong> 数据元素之间的<u>相互关系</u>与<u>组织方式</u>，以及对其施加的<u>运算及运算规则</u>。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>一组<u>性质相同</u>的<strong>值集合</strong>以及定义在这个值集合上的一组<strong>操作</strong>的总称。（即该类型的<strong>取值范围</strong>+该类型种可允许使用的一组<strong>运算</strong>）</p><p><strong>按”值“的不同特性分类：</strong></p><ol><li><p>原子类型：其值不可再分，如整型、实型、字符型及指针。</p></li><li><p>结构类型：其成分既可以是原子，又可以是结构。</p></li></ol><h2 id="抽象数据类型（ADT）"><a href="#抽象数据类型（ADT）" class="headerlink" title="抽象数据类型（ADT）"></a>抽象数据类型（ADT）</h2><p><em>定义了一个<u>数据对象</u>、数据对象种各元素间的<u>结构关系</u>、一组处理数据的<u>操作</u></em>。</p><p><strong>最重要的特点是数据抽象与信息隐蔽</strong></p><p><strong>格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADT&lt;ADT名&gt;</span><br><span class="line">&#123;</span><br><span class="line">    数据对象:&lt;数据对象的定义&gt;</span><br><span class="line">    结构关系:&lt;结构关系的定义&gt;</span><br><span class="line">    基本操作:</span><br><span class="line">    &lt;操作名称&gt;(参数表)</span><br><span class="line">        操作前提:&lt;操作前提描述&gt;</span><br><span class="line">        操作结果:&lt;操作结果描述&gt;</span><br><span class="line">&#125;ADT&lt;ADT名&gt;</span><br></pre></td></tr></table></figure><h1 id="数据结构的内容"><a href="#数据结构的内容" class="headerlink" title="数据结构的内容"></a>数据结构的内容</h1><p>按某种逻辑关系组织起来的一批数据，按一定的映像方式将其存放在计算机的存储器中，并在这些数据上定义一个运算的集合。</p><h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p><em>数据元素之间的逻辑关系描述。</em></p><p>数据结构是一个二元组：(D,R)，D是数据元素的有限集，R是D上的关系集。</p><p><strong>基本结构：</strong></p><ol><li><p>集合结构：属于同一集合，但无任何其他关系</p></li><li><p>线性结构：一对一的线性关系</p></li><li><p>树形结构：一对多的层次关系</p></li><li><p>图结构或网状结构：多对多的任意关系</p></li></ol><p>可概括如下：</p><p>—线性结构——线性表、栈、队、字符串、数组、广义表</p><p>逻辑结构</p><p>—非线性结构——树、图</p><h2 id="数据结构的存储结构（物理结构）"><a href="#数据结构的存储结构（物理结构）" class="headerlink" title="数据结构的存储结构（物理结构）"></a>数据结构的存储结构（物理结构）</h2><p>逻辑结构在计算机中的存储映像，包括<u>数据元素映像</u>和<u>关系映像</u>。</p><p>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</p><p>存储结构分为：顺序存储结构、非顺序存储结构</p><h2 id="数据的运算集合"><a href="#数据的运算集合" class="headerlink" title="数据的运算集合"></a>数据的运算集合</h2><p>如增删改查等操作。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p>规则的有限集合，是为了解决特定问题而规定的一系列操作。</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ol><li><p><strong>有限性</strong>：有限步骤之内正常结束，不能形成无限循环。</p></li><li><p><strong>确定性</strong>：每个步骤有确定含义，无二义性。</p></li><li><p><strong>可行性</strong>：原则上能精确进行。</p></li><li><p>输入：有多个或0个输入。</p></li><li><p>输出：至少有一个或多个输出。</p></li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><ol><li><p>对于几组输入数据能得到满足要求的结果。</p></li><li><p>对于典型、苛刻的输入数据能得到满足要求的结果。</p></li><li><p>对于一切合法的输入数据能得到满足要求的结果。</p></li></ol><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>便于人们理解和相互交流</p><h3 id="健壮性（鲁棒性）"><a href="#健壮性（鲁棒性）" class="headerlink" title="健壮性（鲁棒性）"></a>健壮性（鲁棒性）</h3><p>对非法输入的抵抗能力。</p><h3 id="高效率和低存储量（低耗）"><a href="#高效率和低存储量（低耗）" class="headerlink" title="高效率和低存储量（低耗）"></a>高效率和低存储量（低耗）</h3><p>执行时间越短效率越高，存储量指的是算法执行所需最大存储空间。</p><h1 id="算法性能评价"><a href="#算法性能评价" class="headerlink" title="算法性能评价"></a>算法性能评价</h1><h2 id="算法时间性能分析"><a href="#算法时间性能分析" class="headerlink" title="算法时间性能分析"></a>算法时间性能分析</h2><h3 id="算法耗费的时间"><a href="#算法耗费的时间" class="headerlink" title="算法耗费的时间"></a>算法耗费的时间</h3><p>所有语句执行时间的总和。每条语句的实行时间 = 该语句的执行次数 X 执行一次所需的实际时间</p><h3 id="语句频度"><a href="#语句频度" class="headerlink" title="语句频度"></a>语句频度</h3><p>该语句在一个算法中重复执行的次数。</p><p>算法时间分析的度量标准是根据算法中<u>语句的执行次数</u>估计的。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>语句总的执行次数$ f(n)$，$O$表示数量级。</p><p>时间复杂度 $T(n) = O( f(n) )$</p><h3 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h3><p>与时间复杂度不予区分。</p><h3 id="常用时间复杂度"><a href="#常用时间复杂度" class="headerlink" title="常用时间复杂度"></a>常用时间复杂度</h3><ol><li><p><strong>常数型</strong>：O(1)</p></li><li><p><strong>线性型</strong>：O(n)</p></li><li><p>平方型：O(n<sup>2</sup>)</p></li><li><p>立方型：O(n<sup>3</sup>)</p></li><li><p>指数型：O(2<sup>n</sup>)</p></li><li><p><strong>对数型</strong>：O(log<sub>2</sub>n)</p></li><li><p><strong>二维型</strong>：O(nlog<sub>2</sub>n)</p></li></ol><h3 id="最坏时间复杂度和平均时间复杂度"><a href="#最坏时间复杂度和平均时间复杂度" class="headerlink" title="最坏时间复杂度和平均时间复杂度"></a>最坏时间复杂度和平均时间复杂度</h3><p>最坏情况下的时间复杂度；所有可能的输入实例均以等概率出现的情况下。</p><h2 id="算法空间性能分析"><a href="#算法空间性能分析" class="headerlink" title="算法空间性能分析"></a>算法空间性能分析</h2><h3 id="算法耗费的空间"><a href="#算法耗费的空间" class="headerlink" title="算法耗费的空间"></a>算法耗费的空间</h3><p>算法占用空间是算法实际占用的辅助空间的总和。</p><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>时间复杂度 S(n) = O( f(n) )</p><h2 id="数据结构与c语言表示"><a href="#数据结构与c语言表示" class="headerlink" title="数据结构与c语言表示"></a>数据结构与c语言表示</h2><h3 id="用C语言表示抽象类型"><a href="#用C语言表示抽象类型" class="headerlink" title="用C语言表示抽象类型"></a>用C语言表示抽象类型</h3><h3 id="抽象数据类型的定义格式"><a href="#抽象数据类型的定义格式" class="headerlink" title="抽象数据类型的定义格式"></a>抽象数据类型的定义格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADT Linear_list&#123;</span><br><span class="line">    数据元素</span><br><span class="line">    结构关系</span><br><span class="line">    基本操作：设L为Linear_List,则有</span><br><span class="line">    ① InitList(L):初始化空线性表。</span><br><span class="line">    ② ListLength(L):求线性表的表长</span><br><span class="line">    ③ GetData(L,i):取线性表的第i个元素</span><br><span class="line">    ④ InsList(L,i,b):在线性表第i个位置插入元素b</span><br><span class="line">    ⑤ DelList(L,i):删除线性表的第i个数据元素</span><br><span class="line">&#125;ADT Linear_list</span><br></pre></td></tr></table></figure><h3 id="用C语言实现抽线数据类型"><a href="#用C语言实现抽线数据类型" class="headerlink" title="用C语言实现抽线数据类型"></a>用C语言实现抽线数据类型</h3><ol><li><p>通过<u>结构体</u>将<u>基本数据类型</u>结合到一起，构成一个<strong>结构体类型</strong>，再用<strong>typedef</strong>为该类型或该类型指针<u>重新命名</u>。</p></li><li><p>typdef struct card Card，Card为struct card的别称。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;🚗文档目录：&lt;/p&gt;
&lt;p&gt;🚀&lt;a href=&quot;http://localhost:4000/undefined/dcf64845.html&quot;&gt;绪论&lt;/a&gt;&amp;nbsp; &amp;nbsp; 🚲&lt;a href=&quot;&quot;&gt;线性表&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;数</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
